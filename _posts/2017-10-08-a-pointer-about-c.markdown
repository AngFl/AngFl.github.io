---
layout: post
title:  "C指针的一些重要说明"
date:   2017-06-11 21:27:35 +0800
categories: jekyll update
---


### 运行时例程

很多的编译性语言会将被称为 "run -time rountime" (运行时例程) 的机器码"悄悄地" 嵌入到编译后的程序中去**输入输出**这样的功能就是包含在 ``run -time rountime ``中去。

- 而C 语言基本上没有必要到 "悄悄地" 嵌入运行程序时的复杂功能由于稍复杂的一点功能全部被规划到库中，程序员只需要去显示的调用函数

--- 

<br> 

####  "指针类型"其实不是单独存在的，它是有其他类型派生而成的。

- 也就是说实际上指针存在的类型是 "指向T 类型的指针类型"，
- 不论是指向 int  类型的指针，还是指向 double 类型的指针，都保持相同的表现形式 
- ANSI C 为我们准备了，可以指向任何类型的指针  **``void*``**

- ``*`` 在Pascal 语言中 为了不给调用方的变量带来影响，在定义函数的时候，特变指定了函数参数为变量参数, 如果不指定，编译器会为之给出错误提示。``*`` 在 C 语言中函数的形参都和调用时被设定值的{局部变量}一样。

<br>

#### C语言中大量运用 Syntax sugar(语法糖) 化简了数组使用时的繁琐

- ``{ }``下表运算符 ``[]``和数组没有关系   
- ``{ } ``  ``int *p ``;     
- `` p  =  &array[0]; ``  与  ``( p = array )`` 一样

{% highlight c %}
  for(int i = 0;i < n;i++)
    // p[i] 操作和 *(p + i) 相同 

{% endhighlight %}

-  这种简便的写法  array[i]也可以与p[i]一样，将array解读成**"指向数组初始元素的指针"**,  也就是存在 ``int array[n]  ``这样的声明时一旦后面不追加``[]``, 只写 array 并不代表使 array 具有指向数组第一个元素指针的含义，
无论加不加``[]``,在表达式中  **"数组都可以被解读成指针!"**

- 声明中的`` [] `` 表达数组的意思，声明中的`` [] `` 和表达式中的 `` [] `` 意义完全不同, (PS :  表达式中的 * 和声明中的 * 意义也完全不同) 

- **如果试图将数组作为函数参数进行传递，那就传递指向初始元素的指针,** 如果无论如何都要将数组进行值传递时候，建议将数组整体整理成结构体成员?

<br>

#### 关于空下标 `[ ]` 的运算符

- 对于函数的形参，最外层的数组会被解读成指针，（即使定义了元素个数也会被无视）由初始化表达式可以确定数组大小

{% highlight c %}

double matrix[][2] = {
    {1,0}, 
    {0,1}
};

char *color_name[] = { "red","green","blue"};
// int a[3][3]的省略形式 
int a[][3] = {  
  {1,2,3},
  {4,5},
    {6}
};

// char str[3][5]的省略形式 
char *str[][5] = {  
  "hoge",
  "hog",
  "ho",
};


{% endhighlight %}

- 只有在声明**“函数参数”**的时候，数组的声明才可以被解读成指针

<br>


#### 关于指向函数的指针引起的混乱

- 对于C 语言表达式中的函数可以被解读成 “指向函数的指针”, 在信号处理，事件驱动的程序中 这种特性往往以 “回调函数的形式” 使用
产生混乱的原因： 表达式中的函数可以被解读成 “指向函数的指针” 

- 为了 “照顾这种混乱” ANSIC 标准对语法做了 以下的例外规定
  
1. 表达式中的函数自动转换成 “指向函数的指针” 但是，当函数是地址运算符 & 或者sizeof 操作时, 表达式中的函数不能变换成指向函数的指针。
2. 函数调用运算符() 的操作数不是 “函数” 而是 “函数的指针”, 如果对 “指向函数的指针” 使用解引用 它暂时会成为函数，但是因为在表达式中，所以它会被瞬间地变回  “指向函数的指针”！！

- 结论就是，**即使对“指向函数的指针” 使用 * 运算符，也是对牛弹琴！！**, 
因为此时的 * 没有发挥任何作用！！

{% highlight c %}

    (***********printf)（"hello world\n"）;  //无论如何，  * 没起到作用
{% endhighlight %}

### Char 数组的初始化

- char 数组可以通过以下的方式进行特殊的初始化  ``char str[] = "abc";``

这里的写法其实是下面表达式的语法糖：

{% highlight c %}

    char str[] = {'a','b','c','\0'};
    char str[3] = "abc";  //这里是忘记了 '\0'  

{% endhighlight %}

如果要避免这类错误，应该省略元素个数的定义把对元素的计数工作交给编译器，其实在实际编程中，使用字符串初始化的char 数组情况并不多

一般写成下面的：

{% highlight c %}

    char * str = "abc"; 

{% endhighlight %}

**两者的不同在于：**

- 相对于前者的初始化 char 数组
- 后者是利用字符串常量初始化"指向char 的指针"。 
- 字符串常量一般保存在只读的内存区域，所以后者不能修改字符串的内容。

### 指向 char 指针的数组初始化

- 在需要几个字符串组成的数组时，一般我们使用 "指向char 指针的数组";

{% highlight c %}

  char * color_name[] = {
    "red",
    "green",
    "blue"
  }

{% endhighlight %}





### 结构体的初始化

{% highlight c %}

typedef struct {
      int a;
      int b;
}Hoge;

//可以初始化结构体的内容 :

Hoge hoges = {5,10};

//在对结构体嵌套或结构体中包含的数组的时候

typedef struct {
  int a[10];
  Hoge hoges;
} Piyo;

//可以很好的将各个成员的内容一一对应

Piyo  piyoes = {
  {0,1,2,3,4,5,6,7,8,9},
  {1,2},
}

{% endhighlight %} 

### 共用体的初始化 

- 在ANSIC 中共用体的初始化是针对"第一个成员"实施的！

{% highlight c %}

typedef union {
  int value;
  char *str;
}Hoge;

Hoge hoges = {5};  //初始化表达式应对于 value;


{% endhighlight %}
                            
                        

